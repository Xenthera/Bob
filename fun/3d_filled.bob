import canvas;
import time;
import math;
import matrix;

// 3D Point class
class Point3D {
    var x;
    var y;
    var z;
    
    func init(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
    
    func transform(matrix) {
        var result = matrix.transformPoint(this.x, this.y, this.z);
        return Point3D(result[0], result[1], result[2]);
    }
    
    func project(width, height) {
        // Convert from NDC (-1 to 1) to screen coordinates
        // This is the same as the working wireframe version
        var screenX = (this.x + 1) * width / 2;
        var screenY = (this.y + 1) * height / 2;
        return [screenX, screenY]; // Return only 2D coordinates like wireframe version
    }
}

// Triangle class for filled rendering
class Triangle {
    var vertices;
    var color;
    
    func init(v1, v2, v3, color) {
        this.vertices = [v1, v2, v3];
        this.color = color;
    }
    
    func getZ() {
        // Return average Z for depth sorting
        return (this.vertices[0].z + this.vertices[1].z + this.vertices[2].z) / 3;
    }
    
    func project(width, height) {
        var projected = [];
        foreach(var vertex : this.vertices) {
            projected.push(vertex.project(width, height));
        }
        return projected;
    }
}

// Cube class with triangles
class Cube {
    var originalVertices;
    var vertices;
    var triangles;
    
    func init() {
        // Define cube vertices (8 corners) - larger size
        this.originalVertices = [
            Point3D(-2, -2, -2), // 0: back bottom left
            Point3D(2, -2, -2),  // 1: back bottom right
            Point3D(2, 2, -2),   // 2: back top right
            Point3D(-2, 2, -2),  // 3: back top left
            Point3D(-2, -2, 2),  // 4: front bottom left
            Point3D(2, -2, 2),   // 5: front bottom right
            Point3D(2, 2, 2),    // 6: front top right
            Point3D(-2, 2, 2)    // 7: front top left
        ];
        
        // Initialize transformed vertices to original
        this.vertices = this.originalVertices;
        
        // Define cube triangles using vertex indices (like wireframe edges)
        this.triangles = [
            // Back face (blue)
            [0, 1, 2, "blue"],
            [0, 2, 3, "blue"],
            
            // Front face (green)
            [4, 6, 5, "green"],
            [4, 7, 6, "green"],
            
            // Left face (red)
            [0, 3, 7, "red"],
            [0, 7, 4, "red"],
            
            // Right face (yellow)
            [1, 5, 6, "yellow"],
            [1, 6, 2, "yellow"],
            
            // Top face (magenta)
            [3, 2, 6, "magenta"],
            [3, 6, 7, "magenta"],
            
            // Bottom face (cyan)
            [0, 4, 5, "cyan"],
            [0, 5, 1, "cyan"]
        ];
    }
    
    func transform(modelMatrix, viewMatrix, projectionMatrix) {
        // Transform vertices in two steps for proper depth testing
        // Step 1: Model + View transformation (for depth values)
        var mv = viewMatrix.multiply(modelMatrix);
        var viewSpaceVertices = [];
        foreach(var vertex : this.originalVertices) {
            viewSpaceVertices.push(vertex.transform(mv));
        }
        this.viewSpaceVertices = viewSpaceVertices;
        
        // Step 2: Full MVP transformation (for screen coordinates)
        var mvp = projectionMatrix.multiply(mv);
        var transformedVertices = [];
        foreach(var vertex : this.originalVertices) {
            transformedVertices.push(vertex.transform(mvp));
        }
        this.vertices = transformedVertices;
    }
    
    func getSortedTriangles() {
        // Sort triangles by depth (painter's algorithm)
        var sorted = [];
        foreach(var triangle : this.triangles) {
            sorted.push(triangle);
        }
        
        // Simple bubble sort by Z depth (back to front)
        for(var i = 0; i < sorted.length - 1; i++) {
            for(var j = 0; j < sorted.length - i - 1; j++) {
                // Calculate average Z of triangle vertices in view space
                var z1 = this.viewSpaceVertices[sorted[j][0]].z + this.viewSpaceVertices[sorted[j][1]].z + this.viewSpaceVertices[sorted[j][2]].z;
                var z2 = this.viewSpaceVertices[sorted[j + 1][0]].z + this.viewSpaceVertices[sorted[j + 1][1]].z + this.viewSpaceVertices[sorted[j + 1][2]].z;
                
                if(z1 < z2) {
                    var temp = sorted[j];
                    sorted[j] = sorted[j + 1];
                    sorted[j + 1] = temp;
                }
            }
        }
        
        return sorted;
    }
}

// Depth buffer for z-testing
class DepthBuffer {
    var buffer;
    var width;
    var height;
    
    func init(width, height) {
        this.width = width;
        this.height = height;
        this.buffer = [];
        
        // Initialize depth buffer with maximum depth
        for(var y = 0; y < height; y++) {
            var row = [];
            for(var x = 0; x < width; x++) {
                row.push(-100.0); // Maximum depth for our Z range (negative values)
            }
            this.buffer.push(row);
        }
    }
    
    func clear() {
        for(var y = 0; y < this.height; y++) {
            for(var x = 0; x < this.width; x++) {
                this.buffer[y][x] = -100.0;
            }
        }
    }
    
    func test(x, y, z) {
        if(x < 0 || x >= this.width || y < 0 || y >= this.height) {
            return false;
        }
        
        // Add small tolerance to reduce flickering
        var tolerance = 0.001;
        if(z > this.buffer[y][x] - tolerance) { // Greater Z means closer (less negative)
            this.buffer[y][x] = z;
            return true;
        }
        return false;
    }
}

// Simplified triangle filling algorithm to reduce flickering
func fillTriangle(p1, p2, p3, color, depthBuffer) {
    var width = depthBuffer.width;
    var height = depthBuffer.height;
    
    // Extract coordinates and Z values
    var x0 = p1[0]; var y0 = p1[1]; var z0 = p1[2];
    var x1 = p2[0]; var y1 = p2[1]; var z1 = p2[2];
    var x2 = p3[0]; var y2 = p3[1]; var z2 = p3[2];
    
    // Sort vertices by Y coordinate
    var vertices = [[x0, y0, z0], [x1, y1, z1], [x2, y2, z2]];
    if(vertices[0][1] > vertices[1][1]) {
        var temp = vertices[0];
        vertices[0] = vertices[1];
        vertices[1] = temp;
    }
    if(vertices[1][1] > vertices[2][1]) {
        var temp = vertices[1];
        vertices[1] = vertices[2];
        vertices[2] = temp;
    }
    if(vertices[0][1] > vertices[1][1]) {
        var temp = vertices[0];
        vertices[0] = vertices[1];
        vertices[1] = temp;
    }
    
    var y0 = math.round(vertices[0][1]);
    var y1 = math.round(vertices[1][1]);
    var y2 = math.round(vertices[2][1]);
    
    // Clamp to screen bounds
    y0 = math.max(0, math.min(y0, height - 1));
    y1 = math.max(0, math.min(y1, height - 1));
    y2 = math.max(0, math.min(y2, height - 1));
    
    // Calculate slopes for edge interpolation
    var x0 = vertices[0][0];
    var x1 = vertices[1][0];
    var x2 = vertices[2][0];
    var z0 = vertices[0][2];
    var z1 = vertices[1][2];
    var z2 = vertices[2][2];
    
    // Edge slopes for X
    var slope01_x = (y1 - y0) != 0 ? (x1 - x0) / (y1 - y0) : 0;
    var slope02_x = (y2 - y0) != 0 ? (x2 - x0) / (y2 - y0) : 0;
    var slope12_x = (y2 - y1) != 0 ? (x2 - x1) / (y2 - y1) : 0;
    
    // Current X positions
    var leftX = x0;
    var rightX = x0;
    
    // Use average Z for the entire triangle to reduce flickering
    var avgZ = (z0 + z1 + z2) / 3;
    
    // Fill top half
    for(var y = y0; y <= y1; y++) {
        if(y >= 0 && y < height) {
            var startX = math.round(math.min(leftX, rightX));
            var endX = math.round(math.max(leftX, rightX));
            
            // Clamp to screen bounds
            startX = math.max(0, math.min(startX, width - 1));
            endX = math.max(0, math.min(endX, width - 1));
            
            for(var x = startX; x <= endX; x++) {
                // Depth test with average Z
                if(depthBuffer.test(x, y, avgZ)) {
                    canvas.setColor(color);
                    canvas.putPixel(x, y);
                }
            }
        }
        
        leftX += slope01_x;
        rightX += slope02_x;
    }
    
    // Reset for bottom half
    leftX = x1;
    
    // Fill bottom half
    for(var y = y1; y <= y2; y++) {
        if(y >= 0 && y < height) {
            var startX = math.round(math.min(leftX, rightX));
            var endX = math.round(math.max(leftX, rightX));
            
            // Clamp to screen bounds
            startX = math.max(0, math.min(startX, width - 1));
            endX = math.max(0, math.min(endX, width - 1));
            
            for(var x = startX; x <= endX; x++) {
                // Depth test with average Z
                if(depthBuffer.test(x, y, avgZ)) {
                    canvas.setColor(color);
                    canvas.putPixel(x, y);
                }
            }
        }
        
        leftX += slope12_x;
        rightX += slope02_x;
    }
}

// Initialize canvas
canvas.init();
var size = canvas.getSize();
var width = size[0];
var height = size[1];

// Create depth buffer
var depthBuffer = DepthBuffer(width, height);

// Create cube
var cube = Cube();

// Animation variables
var angleX = 0;
var angleY = 0;
var angleZ = 0;

// Animation loop
while (true) {
    canvas.clear();
    depthBuffer.clear();
    
    // Create transformation matrices
    var modelMatrix = matrix.identityMatrix();
    modelMatrix = modelMatrix.multiply(matrix.translationMatrix(0, 0, -5));
    modelMatrix = modelMatrix.multiply(matrix.rotationXMatrix(angleX));
    modelMatrix = modelMatrix.multiply(matrix.rotationYMatrix(angleY));
    modelMatrix = modelMatrix.multiply(matrix.rotationZMatrix(angleZ));
    
    var viewMatrix = matrix.lookAtMatrix(0, 2, 10, 0, 0, -5, 0, 1, 0);
    var aspect = width / height;
    var projectionMatrix = matrix.perspectiveMatrix(0.5, aspect, 0.1, 100.0);
    
    // Transform cube
    cube.transform(modelMatrix, viewMatrix, projectionMatrix);
    
    // Get sorted triangles (back to front)
    var sortedTriangles = cube.getSortedTriangles();
    
    // Render triangles
    foreach(var triangle : sortedTriangles) {
        // Get vertices by index
        var v0 = cube.vertices[triangle[0]];
        var v1 = cube.vertices[triangle[1]];
        var v2 = cube.vertices[triangle[2]];
        var color = triangle[3];
        
        // Project vertices to 2D
        var p0 = v0.project(width, height);
        var p1 = v1.project(width, height);
        var p2 = v2.project(width, height);
        
        // Check if triangle is visible
        var visible = false;
        if(p0[0] >= 0 && p0[0] < width && p0[1] >= 0 && p0[1] < height) visible = true;
        if(p1[0] >= 0 && p1[0] < width && p1[1] >= 0 && p1[1] < height) visible = true;
        if(p2[0] >= 0 && p2[0] < width && p2[1] >= 0 && p2[1] < height) visible = true;
        
        if(visible) {
            // Backface culling: check if triangle is facing away from camera
            var viewV0 = cube.viewSpaceVertices[triangle[0]];
            var viewV1 = cube.viewSpaceVertices[triangle[1]];
            var viewV2 = cube.viewSpaceVertices[triangle[2]];
            
            // Calculate triangle normal in view space
            var edge1 = [viewV1.x - viewV0.x, viewV1.y - viewV0.y, viewV1.z - viewV0.z];
            var edge2 = [viewV2.x - viewV0.x, viewV2.y - viewV0.y, viewV2.z - viewV0.z];
            
            // Cross product to get normal
            var normal = [
                edge1[1] * edge2[2] - edge1[2] * edge2[1],
                edge1[2] * edge2[0] - edge1[0] * edge2[2],
                edge1[0] * edge2[1] - edge1[1] * edge2[0]
            ];
            
            // Check if normal points away from camera (negative Z means away)
            if(normal[2] > 0) {
                // Triangle is facing away, skip it
                continue;
            }
            
            // Use view space Z values for proper depth testing
            var point1 = [p0[0], p0[1], viewV0.z];
            var point2 = [p1[0], p1[1], viewV1.z];
            var point3 = [p2[0], p2[1], viewV2.z];
            
            fillTriangle(point1, point2, point3, color, depthBuffer);
        }
    }
    
    // Test triangle removed - now showing only 3D cube
    
    // Draw debug info
    canvas.setColor("white");
    canvas.drawText(1, 1, "3D Filled Demo");
    canvas.drawText(1, 2, "Model: X:" + angleX + " Y:" + angleY + " Z:" + angleZ);
    canvas.drawText(1, 3, "Triangles: " + sortedTriangles.length);
    canvas.drawText(1, 4, "Depth Buffer: " + width + "x" + height);
    
    // Debug: Show first triangle coordinates
    if(sortedTriangles.length > 0) {
        var firstTriangle = sortedTriangles[0];
        var v0 = cube.vertices[firstTriangle[0]];
        var v1 = cube.vertices[firstTriangle[1]];
        var p0 = v0.project(width, height);
        var p1 = v1.project(width, height);
        canvas.drawText(1, 5, "First tri: " + p0[0] + "," + p0[1] + " to " + p1[0] + "," + p1[1]);
        canvas.drawText(1, 6, "Raw coords: " + v0.x + "," + v0.y + "," + v0.z);
        canvas.drawText(1, 7, "Screen bounds: " + width + "x" + height);
        
        // Check if any triangle is visible
        var visibleCount = 0;
        foreach(var triangle : sortedTriangles) {
            var v0 = cube.vertices[triangle[0]];
            var v1 = cube.vertices[triangle[1]];
            var v2 = cube.vertices[triangle[2]];
            var p0 = v0.project(width, height);
            var p1 = v1.project(width, height);
            var p2 = v2.project(width, height);
            if(p0[0] >= 0 && p0[0] < width && p0[1] >= 0 && p0[1] < height) visibleCount = visibleCount + 1;
            else if(p1[0] >= 0 && p1[0] < width && p1[1] >= 0 && p1[1] < height) visibleCount = visibleCount + 1;
            else if(p2[0] >= 0 && p2[0] < width && p2[1] >= 0 && p2[1] < height) visibleCount = visibleCount + 1;
        }
        canvas.drawText(1, 8, "Visible triangles: " + visibleCount + "/" + sortedTriangles.length);
        
        // Show Z values for depth debugging
        var firstV0 = cube.viewSpaceVertices[firstTriangle[0]];
        var firstV1 = cube.viewSpaceVertices[firstTriangle[1]];
        var firstV2 = cube.viewSpaceVertices[firstTriangle[2]];
        canvas.drawText(1, 9, "Z values: " + firstV0.z + ", " + firstV1.z + ", " + firstV2.z);
        
        // Show all triangle coordinates
        canvas.drawText(1, 10, "All triangles:");
        for(var i = 0; i < math.min(3, sortedTriangles.length); i++) {
            var tri = sortedTriangles[i];
            var v0 = cube.vertices[tri[0]];
            var v1 = cube.vertices[tri[1]];
            var v2 = cube.vertices[tri[2]];
            var p0 = v0.project(width, height);
            var p1 = v1.project(width, height);
            var p2 = v2.project(width, height);
            canvas.drawText(1, 11 + i, "Tri " + i + ": (" + math.round(p0[0]) + "," + math.round(p0[1]) + ") (" + math.round(p1[0]) + "," + math.round(p1[1]) + ") (" + math.round(p2[0]) + "," + math.round(p2[1]) + ")");
        }
    }
    
    // Update animation
    angleX += 0.2;
    angleY += 0.3;
    angleZ += 0.1;
    
    time.sleep(0.1);
}
