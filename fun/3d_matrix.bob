// 3D Matrix-based Demo with proper coordinate spaces
import canvas;
import time;
import math;
import matrix;

// 3D Point class with matrix transformations
class Point3D {
    var x;
    var y;
    var z;
    
    func init(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
    
    func transform(matrix) {
        var result = matrix.transformPoint(this.x, this.y, this.z);
        return Point3D(result[0], result[1], result[2]);
    }
    
    func project(width, height) {
        // Convert from NDC (-1 to 1) to screen coordinates
        var screenX = (this.x + 1) * width / 2;
        var screenY = (this.y + 1) * height / 2;
        return [screenX, screenY];
    }
}

// Cube class with matrix transformations
class Cube {
    var originalPoints;
    var points;
    var edges;
    
    func init() {
        // Define cube vertices (8 points) - larger size
        this.originalPoints = [
            Point3D(-2, -2, -2),  // 0: back bottom left
            Point3D(2, -2, -2),   // 1: back bottom right
            Point3D(2, 2, -2),    // 2: back top right
            Point3D(-2, 2, -2),   // 3: back top left
            Point3D(-2, -2, 2),   // 4: front bottom left
            Point3D(2, -2, 2),    // 5: front bottom right
            Point3D(2, 2, 2),     // 6: front top right
            Point3D(-2, 2, 2)     // 7: front top left
        ];
        
        // Initialize rotated points to original
        this.points = this.originalPoints;
        
        // Define cube edges (12 edges)
        this.edges = [
            [0, 1], [1, 2], [2, 3], [3, 0],  // back face
            [4, 5], [5, 6], [6, 7], [7, 4],  // front face
            [0, 4], [1, 5], [2, 6], [3, 7]   // connecting edges
        ];
    }
    
    func transform(modelMatrix, viewMatrix, projectionMatrix) {
        // Combine all transformations: projection * view * model
        var mvp = projectionMatrix.multiply(viewMatrix.multiply(modelMatrix));
        
        // Transform all points
        var transformedPoints = [];
        foreach(var point : this.originalPoints) {
            transformedPoints.push(point.transform(mvp));
        }
        this.points = transformedPoints;
    }
    
    func draw(width, height) {
        // Project all points to 2D
        var projectedPoints = [];
        foreach(var point : this.points) {
            projectedPoints.push(point.project(width, height));
        }
        
        // Draw edges using canvas.drawLine
        foreach(var edge : this.edges) {
            var p1 = projectedPoints[edge[0]];
            var p2 = projectedPoints[edge[1]];
            
            // Draw the edge line
            canvas.drawLine(math.round(p1[0]), math.round(p1[1]), math.round(p2[0]), math.round(p2[1]));
        }
    }
}

// Initialize canvas
canvas.init();
var size = canvas.getSize();
var width = size[0];
var height = size[1];

// Create multiple cubes
var centralCube = Cube();
var leftCube = Cube();
var rightCube = Cube();

// Animation variables
var angleX = 0;
var angleY = 0;
var angleZ = 0;

// Camera parameters
var cameraDistance = 10;
var cameraAngle = 0;

// Animation loop
while (true) {
    canvas.clear();
    
    // Set color for cube edges
    canvas.setColor("cyan");
    
    // Create transformation matrices
    
    // View matrix: fixed camera position
    var viewMatrix = matrix.lookAtMatrix(0, 2, 10, 0, 0, -5, 0, 1, 0);
    
    // Projection matrix: perspective
    var aspect = width / height;
    var projectionMatrix = matrix.perspectiveMatrix(0.5, aspect, 0.1, 100.0);
    
    // Draw central cube
    canvas.setColor("cyan");
    var centralModelMatrix = matrix.identityMatrix();
    centralModelMatrix = centralModelMatrix.multiply(matrix.translationMatrix(0, 0, -5));
    centralModelMatrix = centralModelMatrix.multiply(matrix.rotationXMatrix(angleX));
    centralModelMatrix = centralModelMatrix.multiply(matrix.rotationYMatrix(angleY));
    centralModelMatrix = centralModelMatrix.multiply(matrix.rotationZMatrix(angleZ));
    centralCube.transform(centralModelMatrix, viewMatrix, projectionMatrix);
    centralCube.draw(width, height);
    
    // Draw left cube (moving up and down on sin wave, no rotation)
    canvas.setColor("red");
    var leftModelMatrix = matrix.identityMatrix();
    var leftY = math.sin(angleX * 2) * 3; // Sin wave movement
    leftModelMatrix = leftModelMatrix.multiply(matrix.translationMatrix(-8, leftY, -5));
    // No rotation - cube stays upright
    leftCube.transform(leftModelMatrix, viewMatrix, projectionMatrix);
    leftCube.draw(width, height);
    
    // Draw right cube (Y-axis rotation + sin wave movement away from camera)
    canvas.setColor("green");
    var rightModelMatrix = matrix.identityMatrix();
    var rightZ = -8 + math.sin(angleX * 1.5) * 4; // Sin wave movement away from camera (further back, larger range)
    rightModelMatrix = rightModelMatrix.multiply(matrix.translationMatrix(8, 0, rightZ));
    rightModelMatrix = rightModelMatrix.multiply(matrix.rotationYMatrix(angleY)); // Only Y rotation
    rightCube.transform(rightModelMatrix, viewMatrix, projectionMatrix);
    rightCube.draw(width, height);
    

    
    // Draw debug info
    canvas.setColor("yellow");
    canvas.drawText(1, 1, "Multi-Cube 3D Demo");
    canvas.drawText(1, 2, "Central: Cyan (full rotation)");
    canvas.drawText(1, 3, "Left: Red (sin wave movement, no rotation)");
    canvas.drawText(1, 4, "Right: Green (Y-axis rotation + Z sin wave)");
    canvas.drawText(1, 5, "Angles: X:" + angleX + " Y:" + angleY + " Z:" + angleZ);
    canvas.drawText(1, 6, "Camera: Fixed at (0, 2, 10)");
    canvas.drawText(1, 7, "Aspect: " + aspect);
    
    // Update animation
    angleX += 0.02;
    angleY += 0.03;
    angleZ += 0.01;
    
    // Sleep
    time.sleep(0.01);
}
