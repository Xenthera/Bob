import canvas;
import time;
import math;

// Simple triangle filling algorithm
func fillTriangle(p1, p2, p3, color) {
    var width = 164;  // Terminal width
    var height = 32;  // Terminal height
    
    // Sort vertices by Y coordinate
    var vertices = [p1, p2, p3];
    if(vertices[0][1] > vertices[1][1]) {
        var temp = vertices[0];
        vertices[0] = vertices[1];
        vertices[1] = temp;
    }
    if(vertices[1][1] > vertices[2][1]) {
        var temp = vertices[1];
        vertices[1] = vertices[2];
        vertices[2] = temp;
    }
    if(vertices[0][1] > vertices[1][1]) {
        var temp = vertices[0];
        vertices[0] = vertices[1];
        vertices[1] = temp;
    }
    
    var y0 = math.round(vertices[0][1]);
    var y1 = math.round(vertices[1][1]);
    var y2 = math.round(vertices[2][1]);
    
    // Clamp to screen bounds
    y0 = math.max(0, math.min(y0, height - 1));
    y1 = math.max(0, math.min(y1, height - 1));
    y2 = math.max(0, math.min(y2, height - 1));
    
    // Calculate slopes for edge interpolation
    var x0 = vertices[0][0];
    var x1 = vertices[1][0];
    var x2 = vertices[2][0];
    
    // Edge slopes
    var slope01 = (y1 - y0) != 0 ? (x1 - x0) / (y1 - y0) : 0;
    var slope02 = (y2 - y0) != 0 ? (x2 - x0) / (y2 - y0) : 0;
    var slope12 = (y2 - y1) != 0 ? (x2 - x1) / (y2 - y1) : 0;
    
    // Current X positions
    var leftX = x0;
    var rightX = x0;
    
    // Fill top half
    for(var y = y0; y <= y1; y++) {
        if(y >= 0 && y < height) {
            var startX = math.round(math.min(leftX, rightX));
            var endX = math.round(math.max(leftX, rightX));
            
            // Clamp to screen bounds
            startX = math.max(0, math.min(startX, width - 1));
            endX = math.max(0, math.min(endX, width - 1));
            
            for(var x = startX; x <= endX; x++) {
                canvas.setColor(color);
                canvas.putPixel(x, y);
            }
        }
        
        leftX += slope01;
        rightX += slope02;
    }
    
    // Reset for bottom half
    leftX = x1;
    
    // Fill bottom half
    for(var y = y1; y <= y2; y++) {
        if(y >= 0 && y < height) {
            var startX = math.round(math.min(leftX, rightX));
            var endX = math.round(math.max(leftX, rightX));
            
            // Clamp to screen bounds
            startX = math.max(0, math.min(startX, width - 1));
            endX = math.max(0, math.min(endX, width - 1));
            
            for(var x = startX; x <= endX; x++) {
                canvas.setColor(color);
                canvas.putPixel(x, y);
            }
        }
        
        leftX += slope12;
        rightX += slope02;
    }
}

// Initialize canvas
canvas.init();
var size = canvas.getSize();
var width = size[0];
var height = size[1];

print("Canvas size: ", width, "x", height);

// Animation variables
var angle = 0;

// Animation loop
while (true) {
    canvas.clear();
    
    // Create a simple triangle that rotates
    var centerX = width / 2;
    var centerY = height / 2;
    var radius = 10;
    
    // Calculate triangle vertices
    var x1 = centerX + math.cos(angle) * radius;
    var y1 = centerY + math.sin(angle) * radius;
    var x2 = centerX + math.cos(angle + 2.094) * radius;  // 120 degrees
    var y2 = centerY + math.sin(angle + 2.094) * radius;
    var x3 = centerX + math.cos(angle + 4.188) * radius;  // 240 degrees
    var y3 = centerY + math.sin(angle + 4.188) * radius;
    
    // Fill the triangle
    fillTriangle([x1, y1], [x2, y2], [x3, y3], "red");
    
    // Draw debug info
    canvas.setColor("white");
    canvas.drawText(1, 1, "Simple Triangle Demo");
    canvas.drawText(1, 2, "Angle: " + angle);
    canvas.drawText(1, 3, "Triangle: (" + math.round(x1) + "," + math.round(y1) + ") to (" + math.round(x2) + "," + math.round(y2) + ")");
    
    // Update animation
    angle += 0.05;
    
    time.sleep(0.05);
}
