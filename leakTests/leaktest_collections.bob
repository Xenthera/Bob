// Memory leak test: Collection-related scenarios
// Test arrays, dictionaries, and nested structures

print("=== Collection Memory Leak Tests ===");
print("Initial memory: " + memoryUsage() + " MB");

// Test 1: Large nested arrays
print("Test 1: Large nested arrays");
var nestedArrays = [];
for (var i = 0; i < 50000; i++) {
    nestedArrays.push([
        [i, i+1, i+2],
        [i*2, i*3, i*4],
        [[i, [i+1, [i+2]]], i*5]
    ]);
}
print("Created " + nestedArrays.len() + " nested array structures");
print("Memory: " + memoryUsage() + " MB");
input("Press Enter to clear nested arrays...");
nestedArrays = none;
print("Memory after clear: " + memoryUsage() + " MB");
input("Cleared. Check memory usage...");

// Test 2: Large nested dictionaries
print("Test 2: Large nested dictionaries");
var nestedDicts = [];
for (var i = 0; i < 50000; i++) {
    nestedDicts.push({
        "id": i,
        "data": {
            "value": i * 2,
            "nested": {
                "deep": {
                    "deeper": i * 3,
                    "info": "test" + i
                }
            }
        },
        "meta": {
            "created": i,
            "tags": ["tag" + i, "tag" + (i+1)]
        }
    });
}
print("Created " + nestedDicts.len() + " nested dictionary structures");
print("Memory: " + memoryUsage() + " MB");
input("Press Enter to clear nested dicts...");
nestedDicts = [];
print("Memory after clear: " + memoryUsage() + " MB");
input("Cleared. Check memory usage...");

// Test 3: Mixed array/dict structures
print("Test 3: Mixed array/dict structures");
var mixedStructures = [];
for (var i = 0; i < 30000; i++) {
    mixedStructures.push([
        {"arrays": [[i, i+1], [i+2, i+3]]},
        [{"dicts": {"a": i, "b": i+1}}, {"more": [i, i+1]}],
        {
            "complex": [
                {"nested": [i, {"deep": i*2}]},
                [{"very": {"deep": [i, i+1, {"final": i*3}]}}]
            ]
        }
    ]);
}
print("Created " + mixedStructures.len() + " mixed structures");
print("Memory: " + memoryUsage() + " MB");
input("Press Enter to clear mixed structures...");
mixedStructures = "cleared";
print("Memory after clear: " + memoryUsage() + " MB");
input("Cleared. Check memory usage...");

// Test 4: Self-referencing structures (potential cycles)
print("Test 4: Self-referencing structures");
var selfRef = [];
for (var i = 0; i < 1000000; i++) {
    var item = {"id": i, "value": i * 2};
    // Create a structure that references itself
    item["self"] = [item, {"parent": item}];
    selfRef.push(item);
}
print("Created " + selfRef.len() + " self-referencing structures");
print("Memory: " + memoryUsage() + " MB");
input("Press Enter to clear self-ref structures...");
// Break cycles explicitly so reference counting can reclaim memory deterministically
for (var i = 0; i < selfRef.len(); i++) {
    selfRef[i]["self"] = none;
}
selfRef = 123;
print("Memory after clear: " + memoryUsage() + " MB");
input("Cleared. Check memory usage...");

// Test 5: Large string collections
print("Test 5: Large string collections");
var stringCollections = [];
for (var i = 0; i < 100000; i++) {
    var longString = "";
    for (var j = 0; j < 100; j++) {
        longString = longString + "data" + i + "_" + j + " ";
    }
    stringCollections.push({
        "content": longString,
        "words": [longString, longString + "_copy", longString + "_backup"]
    });
}
print("Created " + stringCollections.len() + " string collections");
print("Memory: " + memoryUsage() + " MB");
input("Press Enter to clear string collections...");
stringCollections = none;
print("Memory after clear: " + memoryUsage() + " MB");
input("Cleared. Check memory usage...");

print("=== Collection Tests Complete ===");